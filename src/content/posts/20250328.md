---
layout: ../../layouts/BlogPostLayout.astro
title: 'Anota√ß√µes: Spring Boot'
date: 2025-03-28
draft: false
---

# Pref√°cio
Antes de tudo: estudar *Spring Boot* parece uma bagun√ßa sem fim, e voc√™ n√£o est√° errado. Estudar *Spring Boot* √© uma bagun√ßa!

Por√©m, mesmo com minhas dificuldades eu dei meu jeito. Trago aqui todas as minhas anota√ß√µes relacionadas ao framework que me ajudaram na compreens√£o dos conceitos menos intuitivos que o framework necessita que o programador saiba para construir uma API de qualidade.

N√£o achei a documenta√ß√£o do framework t√£o boa para aprender como dizem, ent√£o tive que fu√ßar internet √° fora para achar conte√∫dos que me ajudassem de fato a compreender os conceitos que fundamentam a estrutura de uma aplica√ß√£o de *API RESTful* em *Spring Boot + Spring Security*.

Pode soar meio confuso de come√ßo entender a estrutura correta para se seguir dentro do framework ao construir aplica√ß√µes web com *API's RESTful* - e realmente, √© um pouco confuso.

# Porqu√™
Estou desenvolvendo um projeto mobile, e nele preciso montar um backend robusto com **muitas** regras de neg√≥cio, o *Java* com *Spring* √© a alternativa mais simples para implementa√ß√£o das ideias.

O projeto consiste em um "gerenciador" de im√≥veis, onde donos de im√≥veis & pessoas que alugam im√≥veis s√£o capazes de registrar essas propriedades; o aplicativo deve ser capaz de devolver todos os impostos a serem pagos pelo usu√°rio de acordo com as cl√°usulas de contrato, juntamente com os reajustes anuais.

# Conceitos iniciais
Nesse projeto achei mais pertinente programar tudo usando a arquitetura de **Web Services**, que pode ser explicada da seguinte forma:

<img src="https://i.imgur.com/Srsn4jK.png" alt="Arq. Web Services" style="width: 100%; height: auto;">

## Princ√≠pios
O uso dessa arquitetura tem o intuito de encapsular melhor as responsabilidades de cada componente do projeto.

Nessa arquitetura temos um alta coes√£o e baixo acoplamento; utilizamos bastante de arquitetura em camadas, inje√ß√£o de depend√™ncias e princ√≠pios do **SOLID** - onde s√£o definidos princ√≠pios de design para cria√ß√£o de c√≥digos mais manunten√≠veis, flex√≠veis e escal√°veis.

- **Controller**: serve como um proxy que comunica o cliente com a aplica√ß√£o. Ele intercepta a comunica√ß√£o e identifica se o request √© ou n√£o v√°lido antes de passar para as outras camadas da aplica√ß√£o. Nessa aplica√ß√£o estamos usando um intermedi√°rio para comunica√ß√£o de dados, chamado de **DTO** - *Data Transfer Object*.
- **Service**: opera como armazenador das regras de neg√≥cio da aplica√ß√£o, aqui operamos e tratamos os dados que o cliente enviou na requisi√ß√£o *HTTP*.
- **Repository**: √© respons√°vel por comunicar o service com o banco de dados da aplica√ß√£o, por estar usando o **Spring Data JPA** todas as opera√ß√µes *SQL* s√£o feitas por debaixo dos panos.

A vis√£o de arquitetura √© importante para definir o caminho √° ser trilhado pelo programador, n√£o ter essas vis√µes pode deixar toda a compreens√£o do framework muito confusa. 

**Posteriormente vou colocar exemplos de c√≥digo de cada classe para exemplifica√ß√£o de como um projeto Spring Boot √© montado.**

# Organiza√ß√£o
```
üì¶ com.example.demo
‚îú‚îÄ¬†DemoApplication
‚îú‚îÄ¬†model/
‚îÇ¬†¬†‚îî‚îÄ¬†UserModel
‚îú‚îÄ¬†controller/
‚îÇ¬†¬†‚îî‚îÄ¬†AuthenticationController
‚îú‚îÄ¬†service/
‚îÇ¬†¬†‚îî‚îÄ¬†UserService
‚îú‚îÄ¬†repository/
‚îÇ¬†¬†‚îî‚îÄ¬†UserRepository
‚îî‚îÄ¬†config/
¬†¬†¬†‚îî‚îÄ¬†SecurityConfig
```
¬©generated by [Project Tree Generator](https://woochanleee.github.io/project-tree-generator)

## Model
No *package* model colocamos todas as classes de entidades do projeto.

O *Spring Boot* utiliza de *"annotations"* para avisar ao framework as responsabilidades das classes que o programador cria.
No exemplo abaixo utilizei as anota√ß√µes de *@Entity* e *@Table* na classe em si para avisar que ela √© uma entidade, e uma tabela no banco de dados.

```java
@Entity
@Table(name = "tb_users")
public class UserModel {
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;

    @Column(nullable = false, unique = true)
    private String username;

    @Column(nullable = false, unique = true)
    private String email;

    @Column(nullable = false)
    private String password;
}
```

## Repository
O *repository* serve como um comunicador, que leva e tr√°s informa√ß√µes de um ponto A at√© um ponto B - **pense que ele age como um carteiro**.

Na aplica√ß√£o em desenvolvimento estou usando o *Spring Data JPA*, ent√£o n√£o preciso escrever *SQL* nas transa√ß√µes, s√≥ sendo necess√°rio instanciar a interface e os m√©todos customizados, caso o programa necessite.

````java
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByEmail(String email);
}
````

## Service
Os *services* atuam como um intermedi√°rio dentro do *controller* e do *repository*, dentro dele colocamos toda a burocracia da aplica√ß√£o, ou seja, as regras de neg√≥cio.

````java
public class UserService {
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;

    public UserService(UserRepository userRepository, PasswordEncoder passwordEncoder) {
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
    }

    public Optional<User> getUserByEmail(String email) {
        return userRepository.findByEmail(email);
    }

    public User createUser(RegisterDto registerDto) {
        var user = new User();

        user.setUsername(registerDto.username());
        user.setEmail(registerDto.email());
        user.setPassword(passwordEncoder.encode(registerDto.password()));

        return userRepository.save(user);
    }
}
````

## Controller
Dentro da *controller* colocamos todas as opera√ß√µes que v√£o ocorrer por interm√©dio de usu√°rio e servi√ßo, servindo como um *proxy* nessas intera√ß√µes.

````java
@RestController
@RequestMapping("/auth") // anota√ß√£o para mapeamento de rota
public class AuthenticationController {
    private final AuthenticationService authenticationService;
    private final UserService userService;

    //inje√ß√£o de depend√™ncias
    public AuthenticationController(AuthenticationService authenticationService, UserService userService) {
        this.authenticationService = authenticationService;
        this.userService = userService;
    }

    @PostMapping("/register")
    public ResponseEntity<String> register(@RequestBody RegisterDto user) {
        try {
            if(userService.getUserByEmail(user.email()).isPresent()) {
                return ResponseEntity.status(HttpStatus.CONFLICT).body("Email j√° cadastrado!");
            }
            userService.createUser(user);
            return ResponseEntity.status(HttpStatus.CREATED).body("Usu√°rio cadastrado com sucesso!");
        } catch (Exception e) {
            e.printStackTrace();
            return ResponseEntity.badRequest().body("Erro ao cadastrar usu√°rio.");
        }

    }

    @PostMapping("/login")
    public ResponseEntity<String> login(@RequestBody LoginDto user) {
        return null;
    }
}
````

# Conclus√£o
Tendo tudo o que foi falado como base j√° conseguimos desenvolver uma aplica√ß√£o em *Java Spring Boot*; por√©m ainda temos de pensar na quest√£o da seguran√ßa da aplica√ß√£o. Futuramente vou escrever outro artigo falando sobre seguran√ßa em aplica√ß√µes *Spring Boot* usando *Spring Security* de forma mais pr√°tica.

Voc√™ obviamente deve saber os conceitos te√≥ricos envolvendo todo o c√≥digo, assim como foi embasado nas explica√ß√µes acima, isso acaba que por gerar uma compreens√£o enorme do c√≥digo que est√° sendo escrito. Pelo fato do Java ser uma linguagem **muito** verbosa, pode ser dif√≠cil decorar o c√≥digo e aprender apenas atrav√©s de exemplos, portanto o melhor dos dois mundos √© ter embasamento te√≥rico e pr√°tico.