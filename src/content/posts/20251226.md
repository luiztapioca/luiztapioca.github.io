---
layout: ../../layouts/BasePostLayout.astro
title: Introdução a Streamings
date: 2025-12-26
draft: true
---

## Prefácio

Atualmente, na busca da minha primeira vaga como júnior, me encontro tendo que aprender tecnologias de mercado que agregam ativamente no meu portfólio de desenvolvedor backend. Dentro disso, comunicação assíncrona de serviços é um tópico mais que essencial; como os serviços se comunicam sem estarem compondo um mesmo monolito? Essa é a pergunta que eu busco responder, de forma clara, com exemplos e diagramas, até o fim dessa postagem.

## Sistemas de Streaming

## Definição

É muito normal confundir a "mensageria" com "mensageira", que são conceitos completamente diferentes na prática:

- Mensageria: A infraestrutura completa que faz o gerenciamento, armazenamento e roteamento dessas mensagens — ex: RabbitMQ, Apache Kafka, etc…
- Mensageira: O conceito de comunicação assíncrona entre sistemas.

## QoS

Tendo isso como base, podemos jogar na mesa alguns conceitos básicos dentro do protocolo MQTT, existem diferentes "Qualities of Service" — dizem respeito ao nível de garantia de entrega das mensagens entre os serviços — que atendem diferentes tipos de necessidade dentro de sistemas:

- QoS 0: at-most-once
    Após a mensagem ser enviada, o sistema "esquece" da sua existência
- QoS 1: at-least-once
    Garante que a mensagem tenha sido recebida pelo cliente pelo menos uma vez, ou seja, podem ter duplicatas de mensagens, caso o sistema falhe no envio do callback.
- QoS 2: exactly-once
    Garante que todas as `n`  mensagens tenham sido recebidas através de um handshake.

Vale lembrar que esses conceitos de QoS são bem limitados ao protocolo MQTT, porém se aplicam a outros tipos de brokers como RabbitMQ ou Apache Kafka, pois o conceito de "performance vs garantia" é teoricamente o mesmo

## Exemplos

Imagine que eu esteja em uma área com uma má cobertura de operadoras de internet, e eu envie uma mensagem para algum conhecido meu…

```
[eu]: olá, preciso que você confira se eu esqueci de desligar o gás em casa... (1)
[eu]: também não se esqueça de se hidratar hoje, o clima está muito seco!      (2)
```

**Dependendo do QoS usado, temos três possíveis caminhos que isso pode tomar:**

1. A mensagem ser enviada, e eu não ter a garantia de que a pessoa recebeu ou não, o que pode ser muito desastroso, caso a mensagem (1) não seja recebida realmente pelo destinatário.

```
[destinatário]: (...)
```
![qos0.png](https://raw.githubusercontent.com/luiztapioca/blog/refs/heads/main/assets/img/qos0.png)

2. A mensagem ser enviada, e eu ter a garantia de que ela foi recebida, porém eu não ter a certeza da quantidade de vezes que foi recebida, eu posso ter enviado duas vezes a mesma mensagem para ele.

```
[destinatário]: OK!
[destinatário]: OK! Pensei que já havia respondido...
```

![qos1.png](https://raw.githubusercontent.com/luiztapioca/blog/refs/heads/main/assets/img/qos1.png)

3. A mensagem ser enviada, e eu ter a garantia de que as duas foram enviadas, esse seria o melhor desfecho.

```
[destinatário]: OK! Vou desligar o gás.
[eu]: OK! Obrigado.
[destinatário]: OK! Vou indo...
```

![qos2.png](https://raw.githubusercontent.com/luiztapioca/blog/refs/heads/main/assets/img/qos2.png)

## Tradeoffs

Tipos diferentes de QoS tem tradeoffs distintos, aumentando gradativamente o uso de recursos computacionais para fazer essa verificação de recebimento de forma eficiente. Enquanto o QoS 1 consegue ser muito barato em recursos computacionais, ao mesmo tempo é imprevisível, temos riscos de duplicatas, logo temos que ter algum meio de validar se algo que está sendo recebido é ou não uma duplicata — idempotência; a alternativa seria usar um QoS 2, porém com um custo computacional bem maior.

> Idempotência se refere à capacidade de executar uma mesma ação, diversas vezes, e ter o mesmo resultado de executar essa ação uma única vez. Em um e-commerce categorizamos cada compra com um UUID distinto. Assim o QoS 1 se tornaria mais eficiente no quesito computacional ao aplicar um armazenamento do estado da compra atrelado ao UUID, ignorando pedidos duplicados.

Acho que com esse exemplo, consegui definir de forma bem objetiva do que se tratam as mensagerias, novamente, a mensageria é uma infraestutura que fornece uma comunicação entre serviços, diminuindo o acoplamento e aumentando consequentemente a eficiência desses serviços, o serviço responsável por enfileirar não fica "pendurado" esperando o destinatário receber a mensagem, o que aumenta substancialmente a vazão da aplicação.

Nesse contexto, podemos variar as decisões de arquitetura, podendo adicionar mais producers, mais consumers, isso varia muito de acordo com o objetivo de escalabilidade da aplicação.

## Conclusão

Vale lembrar que esse post é apenas uma introdução ao que são mensagerias, diferenças de aplicabilidade e conceitos gerais, tentando abstrair ao máximo conceitos mais complexos, e simplificando esse conteúdo que pode parecer complicado a primeira vista.
