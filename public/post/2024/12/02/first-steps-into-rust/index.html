<!DOCTYPE html>
<html lang="pt-br">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>First steps into Rust | Café &amp; Tapioca</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/sobre/">Sobre</a></li>
      
      <li><a href="/categories/">Categorias</a></li>
      
      <li><a href="/tags/">Tags</a></li>
      
      <li><a href="/index.xml">RSS</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">First steps into Rust</span></h1>

<h2 class="date">12/02/2024</h2>
</div>

<main>
<h1 id="why-im-learning-rust">Why I&rsquo;m learning Rust?</h1>
<p>Basically, I was planning on studying compilers, interpreters and how programming languages work on the low level part.</p>
<p>I tought that Rust was a good choice because it has large and active open source community, and it&rsquo;s simpler than C and C++. I had sometime in last year learning C, was a pain in the ass, but I recognize the impact that it had in my understanding of how a computer memory works on the low level.</p>
<ul>
<li>
<p>I&rsquo;m learning Rust using the <a href="https://doc.rust-lang.org/book/title-page.html">official book</a>.</p>
</li>
<li>
<p>I read until the charpter <a href="https://doc.rust-lang.org/book/ch03-05-control-flow.html">3.5</a></p>
</li>
<li>
<p>As a summary, today I learned:</p>
</li>
</ul>
<ol>
<li>Data Types;</li>
<li>Functions;</li>
<li>Variables &amp; Mutability</li>
</ol>
<p>Rust has a pretty interesting approach to variables, unlike C, Rust don&rsquo;t let all variables be mutable. In a deeper level it offers more memory safe code, leading to lesser bugs on runtime.</p>
<h2 id="guessing-game">Guessing game:</h2>
<pre><code class="language-rust">use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {

    // rust uses snake case as default
    println!(&quot;Secret number game!&quot;);
    let secret_number = rand::thread_rng().gen_range(1..=100);

    loop {
        let mut guess = String::new();
        println!(&quot;The secret number is: {secret_number}&quot;);
        println!(&quot;Type a number:&quot;);

        io::stdin()
            .read_line(&amp;mut guess)
            .expect(&quot;Failed to read the line!&quot;);

        // match is basically a switch case
        // in this case i'm using him to handle exceptions
        // just like on the line 32

        // the parse method returns a **enum** 
        // it can be &quot;Ok&quot; or &quot;Err&quot;, using the method 
        // match i can handle the excpetion in the case of either are returned 
        // &quot;Err(_)&quot; is basically a catch all

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        }; 

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;You win!&quot;);
                break;
            },
        }
    }
}
</code></pre>
<h2 id="learning-how-variables-work">Learning how variables work:</h2>
<pre><code class="language-rust">fn main() {

    // incorrect way to re-declare variables:
    // x = x (only works for mutable variables)
    let x = 6;
    println!(&quot;x is {x}&quot;);

    // shadowing variables
    // I can also do let x = x * 5!!
    let x = 5;
    println!(&quot;x is {x}&quot;);

    // constants are **always** immutable, unlike variables.
    const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;

    // inner scope and shadowing variables:
    let x = x + 1;

    {
        // this is an inner scope
        let x = x * 2;
        println!(&quot;x is {x}&quot;);
    }

    // the main difference between using shadowing and mut
    // is that mutable variables can be changed at any time,
    // while regular variables return to being immutable after modifications.
    // basically, we are creating a new variable but with the same name.
    println!(&quot;x is {x}&quot;);

    let spaces = &quot;   &quot;;
    let spaces = spaces.len();
    println!(&quot;spaces len is {spaces}&quot;);

    // incorrect way to re-declare variables:
    // let mut spaces_mut = &quot;   &quot;;
    // spaces_mut = spaces_mut.len();
    //
    // **compilation error, because it is not possible to mutate the variable type.**
    // this is only possible with regular variables because they are being
    // re-created in every re-declaration.
    
    // I need to define the type beforehand
    // let guess = &quot;42&quot;.parse().expect(&quot;Failed to parse!&quot;);

    let guess: u32 = &quot;42&quot;.parse().expect(&quot;Failed to parse!&quot;);
}

</code></pre>
<h2 id="array-study">Array study:</h2>
<pre><code class="language-rust">fn main() {
    let mut counter: u32 = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter;
        } 
    };

    println!(&quot;result is {result}&quot;);

    let mut number: u32 = 3;
    println!(&quot;number is {number}&quot;);

    while number != 0 {
        number -= 1
    }
    println!(&quot;number has reached {number}&quot;);

    while number &lt; 10 {
        number += 1;
    }
    println!(&quot;number has reached {number}&quot;);

    let mut index: usize = 0;
    let arr: [u32; 5] = [0, 1, 2, 3, 4];

    while index &lt; 5 {
        println!(&quot;element is {}&quot;, arr[index]);
        index += 1;
    }

    // instead of looping with a size of 5, which can cause errors,
    // I can loop directly over the collection `arr`, as follows:

    println!(&quot;\n&quot;);
    for element in arr {
        println!(&quot;element is {element}&quot;);
    }

    println!(&quot;\n&quot;);

    for element in (1..4).rev() {
        println!(&quot;element is {element}&quot;);
    }
}

</code></pre>
<table>
<thead>
<tr>
<th><img src="/thinking_monke.jpg" alt="thinking_monke.jpg"></th>
</tr>
</thead>
<tbody>
<tr>
<td>today was a very productive day, I studied for 2.5 hours</td>
</tr>
</tbody>
</table>

</main>

  <footer>
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<script src="//cdn.jsdelivr.net/npm/@xiee/utils/js/math-code.min.js" defer></script>
<script src="//cdn.jsdelivr.net/npm/katex/dist/katex.min.js" defer></script>
<script src="//cdn.jsdelivr.net/npm/katex/dist/contrib/auto-render.min.js" defer></script>
<script src="//cdn.jsdelivr.net/npm/@xiee/utils/js/render-katex.js" defer></script>

<script src="//cdn.jsdelivr.net/npm/@xiee/utils/js/center-img.min.js" defer></script>

  
  <hr/>
  © Luiz G. 2024 &ndash; 2025 | <a href="https://github.com/1917dc">Github</a> | <a href="https://last.fm/user/gfxnx">Lastfm</a> | <a href="https://letterboxd.com/yyounevershould/">Letterboxd</a> | <a href="https://www.instagram.com/1917.dc">Instagram</a>
  
  </footer>
  </body>
</html>

