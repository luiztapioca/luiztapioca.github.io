<!DOCTYPE html>
<html lang="pt-br" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>First steps into Rust | Café &amp; Tapioca</title>
<link rel="icon" href="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha512-DxV+EoADOkOygM4IR9yXP8Sb2qwgidEmeqAEmDKIOfPRQZOWbXCzLC6vjbZyy0vPisbH2SyW27+ddLVCN+OMzQ==" crossorigin="anonymous" referrerpolicy="no-referrer" />
<link rel="stylesheet" href="/css/main.css">
<script src="/js/main.js"></script>


<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
</head>
<body>
  <header>
    <div class="header">
    <div class="logo-container">
        <img class="logo" src="" alt="Café &amp; Tapioca">
        <h1>Café &amp; Tapioca</h1>
    </div>
    
  <nav>
    <ul class="menu">
    <li class="menu">
      <a>Home</a>
    </li>
    <li class="menu">
      <a href="sobre/">Sobre</a>
    </li>
    <li class="menu">
      <a href="categories/">Categorias</a>
    </li>
    <li class="menu">
      <a href="tags/">Tags</a>
    </li>
    <li class="menu">
      <a href="index.xml">RSS</a>
    </li>
    </ul>
  </nav>

</div>
  </header>
  <div class="divider"></div>
  <main>
    
  <div class="post-header">
    <h1 class="post-header-title">First steps into Rust</h1>
      
      <p class="post-date">
        <i class="fas fa-clock"></i>
        
        <time datetime="2024.12.02">2024.12.02</time>
      </p>
  </div>
  
  <div class="terms">
    <div>
      Tags:
    </div>
        <p><a href="/tags/rust/">Rust</a></p>
  </div>


  <h1 id="why-im-learning-rust">Why I&rsquo;m learning Rust?</h1>
<p>Basically, I was planning on studying compilers, interpreters and how programming languages work on the low level part.</p>
<p>I tought that Rust was a good choice because it has large and active open source community, and it&rsquo;s simpler than C and C++. I had sometime in last year learning C, was a pain in the ass, but I recognize the impact that it had in my understanding of how a computer memory works on the low level.</p>
<ul>
<li>
<p>I&rsquo;m learning Rust using the <a href="https://doc.rust-lang.org/book/title-page.html">official book</a>.</p>
</li>
<li>
<p>I read until the charpter <a href="https://doc.rust-lang.org/book/ch03-05-control-flow.html">3.5</a></p>
</li>
<li>
<p>As a summary, today I learned:</p>
</li>
</ul>
<ol>
<li>Data Types;</li>
<li>Functions;</li>
<li>Variables &amp; Mutability</li>
</ol>
<p>Rust has a pretty interesting approach to variables, unlike C, Rust don&rsquo;t let all variables be mutable. In a deeper level it offers more memory safe code, leading to lesser bugs on runtime.</p>
<h2 id="guessing-game">Guessing game:</h2>
<pre><code class="language-rust">use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {

    // rust uses snake case as default
    println!(&quot;Secret number game!&quot;);
    let secret_number = rand::thread_rng().gen_range(1..=100);

    loop {
        let mut guess = String::new();
        println!(&quot;The secret number is: {secret_number}&quot;);
        println!(&quot;Type a number:&quot;);

        io::stdin()
            .read_line(&amp;mut guess)
            .expect(&quot;Failed to read the line!&quot;);

        // match is basically a switch case
        // in this case i'm using him to handle exceptions
        // just like on the line 32

        // the parse method returns a **enum** 
        // it can be &quot;Ok&quot; or &quot;Err&quot;, using the method 
        // match i can handle the excpetion in the case of either are returned 
        // &quot;Err(_)&quot; is basically a catch all

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        }; 

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;You win!&quot;);
                break;
            },
        }
    }
}
</code></pre>
<h2 id="learning-how-variables-work">Learning how variables work:</h2>
<pre><code class="language-rust">fn main() {

    // incorrect way to re-declare variables:
    // x = x (only works for mutable variables)
    let x = 6;
    println!(&quot;x is {x}&quot;);

    // shadowing variables
    // I can also do let x = x * 5!!
    let x = 5;
    println!(&quot;x is {x}&quot;);

    // constants are **always** immutable, unlike variables.
    const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;

    // inner scope and shadowing variables:
    let x = x + 1;

    {
        // this is an inner scope
        let x = x * 2;
        println!(&quot;x is {x}&quot;);
    }

    // the main difference between using shadowing and mut
    // is that mutable variables can be changed at any time,
    // while regular variables return to being immutable after modifications.
    // basically, we are creating a new variable but with the same name.
    println!(&quot;x is {x}&quot;);

    let spaces = &quot;   &quot;;
    let spaces = spaces.len();
    println!(&quot;spaces len is {spaces}&quot;);

    // incorrect way to re-declare variables:
    // let mut spaces_mut = &quot;   &quot;;
    // spaces_mut = spaces_mut.len();
    //
    // **compilation error, because it is not possible to mutate the variable type.**
    // this is only possible with regular variables because they are being
    // re-created in every re-declaration.
    
    // I need to define the type beforehand
    // let guess = &quot;42&quot;.parse().expect(&quot;Failed to parse!&quot;);

    let guess: u32 = &quot;42&quot;.parse().expect(&quot;Failed to parse!&quot;);
}

</code></pre>
<h2 id="array-study">Array study:</h2>
<pre><code class="language-rust">fn main() {
    let mut counter: u32 = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter;
        } 
    };

    println!(&quot;result is {result}&quot;);

    let mut number: u32 = 3;
    println!(&quot;number is {number}&quot;);

    while number != 0 {
        number -= 1
    }
    println!(&quot;number has reached {number}&quot;);

    while number &lt; 10 {
        number += 1;
    }
    println!(&quot;number has reached {number}&quot;);

    let mut index: usize = 0;
    let arr: [u32; 5] = [0, 1, 2, 3, 4];

    while index &lt; 5 {
        println!(&quot;element is {}&quot;, arr[index]);
        index += 1;
    }

    // instead of looping with a size of 5, which can cause errors,
    // I can loop directly over the collection `arr`, as follows:

    println!(&quot;\n&quot;);
    for element in arr {
        println!(&quot;element is {element}&quot;);
    }

    println!(&quot;\n&quot;);

    for element in (1..4).rev() {
        println!(&quot;element is {element}&quot;);
    }
}

</code></pre>
<table>
<thead>
<tr>
<th><img src="/thinking_monke.jpg" alt="thinking_monke.jpg"></th>
</tr>
</thead>
<tbody>
<tr>
<td>today was a very productive day, I studied for 2.5 hours</td>
</tr>
</tbody>
</table>


  </main>
  <div class="divider"></div>
  <footer>
    <div class="footer">
    <p>Copyright &copy;   - 2025.</p>
</div>
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script>
  </footer>
</body>
</html>
